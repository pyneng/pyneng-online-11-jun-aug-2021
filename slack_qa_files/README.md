# Вопросы и ответы из slack

* [Вопросы pyneng-9](https://github.com/pyneng/pyneng-online-9-may-aug-2020/tree/master/slack_qa_files)
* [Вопросы pyneng-10](https://github.com/pyneng/pyneng-online-10-jan-apr-2021/tree/main/slack_qa_files)


## a == b или a is b

`==` проверяет значения, а is проверяет что обе переменные ссылаются на один и тот же объект.
Соответственно для проверки того что значение одной переменной равно какому-то другому значению,
надо использовать `==`.

`is` может использоваться при проверке, что значение равно None:

```python
data is None
data is not None
```

В остальных случаях лучше использовать `==`:

```python
len(data) == 4
len(data) != 4
```

## Можно ли сделать паровозик из методов list.pop?

Можно сделать паровозик, но только в определенных условиях. pop работает только на списках (технически и на словарях).

То есть можно сделать паровоз с pop если у нас список списков
```python
In [112]: data = [[1, 100, 1000], [2, 2, 2], [1, 2, 3], [4, 100, 3]]

In [113]: data.pop()
Out[113]: [4, 100, 3]

In [114]: data.pop().pop()
Out[114]: 3

In [115]: data.pop(1).pop(2)
Out[115]: 2
```

но еще один pop не сработает потому что это уже число
```python
In [116]: data.pop(1).pop(2).pop(1)
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-116-0659e6e22071> in <module>
----> 1 data.pop(1).pop(2).pop(1)
IndexError: pop index out of range
```

## Отличие sys.stdout и print

Разница между print и sys.stdout в том, что print это красивая и простая оболочка вокруг sys.stdout.
С print вместо:

```python
import sys
sys.stdout.write("test")
```

можно писать
```python
print("test")
```

Плюс в print можно передавать что угодно, в sys.stdout только строку.
И в print есть мелкие параметры для управления тем что поставится между элементами, что в конце вывода и так далее.


## Почему список/словарь в который собираются данные в функции, надо создавать внутри функции

Очень часто в решении заданий встречается такой нюанс: функция должна собрать какие-то данные в список/словарь
и список создан вне функции. Тогда вроде как функция работает правильно,
 но при этом тест не проходит. Это происходит потому что в таком варианте функция
 работает неправильно и каждый вызов добавляет элементы в тот же список:

```python
In [1]: result = []

In [2]: def func(items):
   ...:     for i in items:
   ...:         result.append(i*100)
   ...:     return result
   ...:

In [3]: func([1, 2, 3])
Out[3]: [100, 200, 300]

In [4]: func([7, 8])
Out[4]: [100, 200, 300, 700, 800]
```

Исправить это можно переносом списка в функцию

```python
In [20]: def func(items):
    ...:     result = []
    ...:     for i in items:
    ...:         result.append(i*100)
    ...:     return result
    ...:

In [21]: func([1, 2, 3])
Out[21]: [100, 200, 300]

In [22]: func([7, 8])
Out[22]: [700, 800]
```

Всё, что относится к функции лучше всегда писать внутри функции.
Тест тут не проходит потому что внутри файла задания функция вызывается первый раз - всё ок, а потом тест вызывает её второй раз и там вдруг в два раза больше данных чем нужно.


## Есть ли какие-то рекомендации по поводу расположения функций в коде?

В [PEP8](https://pep8.org/) нет рекомендаций по этому поводу.

Если скрипт в одном файле, обычно порядок такой:
1. shebang, file encoding
2. docstring модуля
3. импорт
4. константы
5. все функции в условно произвольном порядке, то есть тут уже самому надо решить как удобнее 
6. функции/код для создания CLI если есть
7. Часто, если есть код который надо писать глобально, а не в функции, создают функцию main
8. `if __name__ == "__main__":` и вызов функции main или глобального кода, который вызывает функции


При этом среди функций обычно выбирают для себя какой-то порядок, чтобы он был плюс-минус однотипным
в разных файлах. Например, сначала пишем общие функцие, которые не зависят от других функций в файле,
потом те что зависят. При этом обычно есть какой-то порядок выполнения действий: подключились на оборудование
и считали вывод, парсим его, записали результат в файл - тогда соблюдаем этот порядок в функциях.

> [О структуре больших проектов](https://docs.python-guide.org/writing/structure/). И еще одна ссылка по этой же теме, с [примерами структуры проектов Flask/Django](https://realpython.com/python-application-layouts/).
